#ifndef MEPHISTO_DETAIL_META
#define MEPHISTO_DETAIL_META
#include <alpaka/alpaka.hpp>

#include <mephisto/array>
#include <mephisto/type_traits>
#include <type_traits>

#include <iostream>

#include <libdash.h>

namespace mephisto {

namespace detail {
template <std::size_t n>
struct arr_to_vec {
  template <typename T>
  static auto create(T &arr)
  {
    return arr[n];
  }
};
}  // namespace detail

/**
 * Information about a local chunk of memory and its coordinates relative to
 * the global origin.
 */
template <std::size_t Dim>
struct Metadata {
  using dim_t = alpaka::dim::DimInt<Dim>;
  using vec_t = alpaka::vec::Vec<dim_t, std::size_t>;

private:
  vec_t _offsets;
  vec_t _extents;

public:
  ALPAKA_FN_HOST_ACC Metadata(vec_t offsets, vec_t extents)
    : _offsets(offsets)
    , _extents(extents)
  {
  }

  ALPAKA_FN_HOST Metadata(
      LocalArray<std::size_t, Dim> offsets,
      LocalArray<std::size_t, Dim> extents)
    : _offsets(alpaka::vec::createVecFromIndexedFn<dim_t, detail::arr_to_vec>(
          offsets))
    , _extents(alpaka::vec::createVecFromIndexedFn<dim_t, detail::arr_to_vec>(
          extents))
  {
  }


  ALPAKA_FN_HOST_ACC
  auto offsets() const
  {
    return _offsets;
  }

  ALPAKA_FN_HOST_ACC
  auto extents() const
  {
    return _extents;
  }

  ALPAKA_FN_HOST_ACC
  auto size() const
  {
    return _extents.sum();
  }
};

template <
    typename Element,
    typename Entity,
    std::size_t Dim,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
struct DeviceDataBuffer {
  using Meta     = Metadata<Dim>;
  using device_t = typename entity_traits::device<Entity>::type;
  using acc_t    = typename entity_traits::acc<Entity>::type;

  // We need to save the PlainPtr views here, so we don't have to keep an
  // instance of the device here, too.
  using meta_view_t = alpaka::mem::view::
      ViewPlainPtr<device_t, Meta, alpaka::dim::DimInt<1>, std::size_t>;
  using data_view_t = alpaka::mem::view::ViewPlainPtr<
      device_t,
      Element,
      alpaka::dim::DimInt<Dim>,
      std::size_t>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  Element *   _data;
  void *      _base;
  std::size_t _entity_index;

  DeviceDataBuffer(Entity ent, Element *base)

    : _base(base)
    , _entity_index(ent.index())
    , _data(reinterpret_cast<Element *>(
          reinterpret_cast<char *>(base) + MetaOffset))
  {
  }

  ALPAKA_FN_HOST_ACC
  Meta &meta()
  {
    // get the memory MetaOffset bytes before data
    return *reinterpret_cast<Meta *>(_base);
  }

  ALPAKA_FN_HOST_ACC
  meta_view_t meta_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        &meta(), entity().device(), static_cast<std::size_t>(1));
  }

  ALPAKA_FN_HOST_ACC
  data_view_t data_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        begin(), entity().device(), meta().extents());
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *begin() const
  {
    return _data;
  }

  /**
   * Returns the one-past-end pointer
   */
  ALPAKA_FN_HOST_ACC
  Element *end() const
  {
    return begin() + meta().size();
  }

  Entity entity() const
  {
    return Entity(_entity_index);
  }
};

/**
 * Data buffer is used to reduce the number of parameters to avoid hitting the
 * 256 byte limit.
 *
 * buf[[meta]..<padding>..[data...]]
 *
 */
template <
    typename Element,
    typename Device,
    std::size_t Dim,
    typename Alignment =
        typename alpaka::core::align::OptimalAlignment<sizeof(Element)>::type>
class HostDataBuffer {
  using NonConstElement = typename std::remove_const<Element>::type;
  using Host            = alpaka::dev::DevCpu;
  using Meta            = Metadata<Dim>;
  using DimInt          = alpaka::dim::DimInt<Dim>;
  using Idx             = std::size_t;
  using DeviceBuf =
      DeviceDataBuffer<NonConstElement, Device, Dim, Alignment>;
  using HostBuf =
      alpaka::mem::view::ViewPlainPtr<Host, NonConstElement, DimInt, Idx>;

  static constexpr size_t MetaOffset =
      sizeof(Meta) + sizeof(Meta) % Alignment::value;

  Element *   _begin;
  std::size_t _nelems;
  std::size_t _bufsize;
  Meta        _meta;

public:
  template<typename Vec>
  HostDataBuffer(Vec viewspec, Element *begin)
    : _begin(begin)
    , _meta(viewspec.offsets(), viewspec.extents())
    , _nelems(viewspec.size())
    , _bufsize(sizeof(Meta) + _nelems * sizeof(Element) + Alignment::value)
  {
  }

  // TODO: extract into proper allocator?
  template <typename Entity>
  auto alloc_entity_buf(Entity &entity)
  {
    // Return a newly created and allocated buffer
    auto buf =
        alpaka::mem::buf::alloc<char, std::size_t>(entity.device(), _bufsize);
    return DeviceBuf{entity,
                        reinterpret_cast<NonConstElement *>(
                            alpaka::mem::view::getPtrNative(buf))};
  }

  template <typename Entity>
  DeviceBuf getDeviceDataBuffer(Entity &entity)
  {
    auto accBuf = alpaka::mem::view::getPtrNative(entity.deviceBuf);
    // Add MetaOffset bytes offset to the accBuf address */
    auto deviceBufAddr = reinterpret_cast<NonConstElement *>(
        reinterpret_cast<char *>(accBuf) + MetaOffset);
    return DeviceBuf(deviceBufAddr);
  }

  Meta &meta()
  {
    return _meta;
  }

  Element *data() const

  {
    return _begin;
  }

  auto host() const
  {
    return Host{alpaka::pltf::getDevByIdx<alpaka::pltf::PltfCpu>(0u)};
  }

  /* auto getDeviceMetaView() */
  /* { */
  /*   auto devicePtr = alpaka::mem::view::getPtrNative(deviceBuf); */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, Meta, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<Meta *>(devicePtr), context.accDevice,
   * static_cast<std::size_t>(1)); */
  /* } */

  auto meta_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        &_meta, host(), static_cast<std::size_t>(1));
  }

  /* auto getDeviceDataView() */
  /* { */
  /* //, deviceBuf( */
  /*  //     alpaka::mem::buf::alloc<char, size_t>(context.accDevice,
   * bufsize)) */
  /*   return alpaka::mem::view::ViewPlainPtr<Device, NonConstElement, */
  /*                                          alpaka::dim::Dim<std::size_t>,
   */
  /*                                          alpaka::idx::Idx<std::size_t>>(
   */
  /*       reinterpret_cast<NonConstElement *>( */
  /*           reinterpret_cast<char *>( */
  /*               alpaka::mem::view::getPtrNative(deviceBuf)) + */
  /*           MetaOffset), */
  /*       context.accDevice, static_cast<std::size_t>(datasize)); */
  /* } */

  HostBuf data_view()
  {
    return alpaka::mem::view::createStaticDevMemView(
        data(), host(), _meta.extents());
  }

  size_t datasize() const
  {
    return _nelems * sizeof(Element);
  }

  size_t nelems() const
  {
    return _nelems;
  }

  size_t bufsize() const
  {
    return _bufsize;
  }

  auto extents() const {
    return _meta.extents();
  }
};

}  // namespace mephisto

#endif
